import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for Variant
import "blueprint.variant_proxy" for VariantProxy
import "sketchgraph.variant" for VAR_TYPE_CONSTRAINT, VAR_TYPE_SKETCH, VarConstraint, VarSketch, VarGeometry, VarGeoPoint
import "sketchgraph.context" for CONTEXT
import "sketchnetwork.nodes.sketchgraph" for Sketchgraph
import "sketchnetwork.nodes.geometry" for Geometry
import "geometry" for Point, Line, Circle, Arc, Ellipse

class Scene
{
	init()
	{
	}

	resolve(scene, out_list)
	{
		var geos = []
		var cons = []
		this.resolve_nodes(scene, geos, cons)
		this.resolve_conns(scene, cons)

		var sk = VarSketch()
		sk.geos = Variant(geos)
		sk.cons = Variant(cons)

		var sketches = []
		this.resolve_sketches(scene, sketches)
		sketches.add(Variant(VAR_TYPE_SKETCH, sk))

		import "sketchgraph.nodes.sk_solver" for SkSolver
		var solver = SkSolver()
		Blueprint.connect(VariantProxy(Variant(sketches)), 0, solver, "sketch")

		var v_geos = Blueprint.calc_output_value(solver, "geos")
		if (v_geos) {
			for (var geo in v_geos.value) {
				out_list.add(geo)
			}
		}
	}

	resolve_sketches(scene, sketches)
	{
		for (var node in scene.nodes) 
		{
			var bp_node = node.components["bp"]
			if (bp_node and bp_node is Sketchgraph)
			{
				var v_sketch = bp_node.calc_output_sketch()
				if (v_sketch) {
					sketches.add(v_sketch)
				}
			}
		}
	}

	resolve_nodes(scene, geos, cons)
	{
		for (var node in scene.nodes) 
		{
			var bp_node = node.components["bp"]
			if (bp_node)
			{
				if (bp_node.has_method("resolve_geo()")) {
					geos.add(bp_node.resolve_geo())
				} else if (bp_node.has_method("resolve_cons()")) {
					cons.add(bp_node.resolve_cons())
				}
			}
		}		
	}

	resolve_conns(scene, cons)
	{
		for (var node in scene.nodes) 
		{
			var bp_node = node.components["bp"]
			if (bp_node)
			{
				for (var p in bp_node.pins)
				{
					var e = p.edge
					if (e.pin0.vert == bp_node) 
					{
						var geo_0 = this.trans_to_geo(e.pin0)
						var geo_1 = this.trans_to_geo(e.pin1)
						if (geo_0 and geo_1) 
						{
							var c = this.gen_cons_between_2geos(geo_0, geo_1)
							if (c) {
								cons.add(c)
							}
						}
					}
				}
			}
		}
	}

	trans_to_geo(pin)
	{
		var vert = pin.vert
		if (vert is Geometry) {
			return vert.resolve_geo().value
		} else if (vert is Sketchgraph) {
			return vert.get_input_geo(pin)
		} else {
			return nil
		}
	}

	gen_cons_between_2geos(geo_0, geo_1)
	{
		var point = 0
		var line = 0
		var circle = 0
		var arc = 0
		var ellipse = 0

		fun get_shape_type(geo)
		{
			if (geo is VarGeometry)
			{
				var shape = geo.shape
				if (shape is Point) {
					point = point + 1
				} else if (shape is Line) {
					line = line + 1
				} else if (shape is Circle) {
					circle = circle + 1
				} else if (shape is Arc) {
					arc = arc + 1
				} else if (shape is Ellipse) {
					ellipse = ellipse + 1
				}
			}
			else if (geo is VarGeoPoint)
			{
				point = point + 1
			}
		}

		get_shape_type(geo_0)
		get_shape_type(geo_1)

		if (point > 0)
		{
			if (point > 1) {
//				return this.create_cons("coincident", geo_0, geo_1)
				return this.create_cons("distance", geo_0, geo_1)
			} else if (line > 0) {
				return this.create_cons("point_on_line", geo_0, geo_1)
			} else if (circle > 0) {
				return this.create_cons("point_on_circle", geo_0, geo_1)
			} else if (arc > 0) {
				return this.create_cons("point_on_arc", geo_0, geo_1)
			} else if (ellipse > 0) {
				return this.create_cons("point_on_ellipse", geo_0, geo_1)
			}
		}
		else if (line > 0)
		{
			if (line > 1) {
				return this.create_cons("parallel", geo_0, geo_1)
			} else if (circle > 0) {
				return this.create_cons("tangent", geo_0, geo_1)
			} else if (arc > 0) {
				return this.create_cons("tangent", geo_0, geo_1)
			} else if (ellipse > 0) {
				return this.create_cons("tangent", geo_0, geo_1)
			}
		}
		else if (circle > 0)
		{
			if (circle > 1) {
				return this.create_cons("tangent_circumf", geo_0, geo_1)
			} else if (arc > 0) {
				return this.create_cons("tangent", geo_0, geo_1)
			} else if (ellipse > 0) {
				return this.create_cons("tangent", geo_0, geo_1)
			}
		}

		return nil
	}

	create_cons(type, a, b)
	{
		var id = CONTEXT.advance_cons_id()
		var val = 0
		var driving = true
		var cons = VarConstraint(id, type, a, b, val, driving)
		return Variant(VAR_TYPE_CONSTRAINT, cons)		
	}
}