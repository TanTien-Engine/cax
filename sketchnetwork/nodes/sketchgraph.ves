import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for Variant
import "blueprint.variant_proxy" for VariantProxy
import "blueprint.nodes.subgraph" for Subgraph
import "network.vertex" for Vertex
import "network.pin" for Pin
import "network.vertex_shape" for SHAPE_PANEL
import "sketchgraph.variant" for VAR_TYPE_GEOMETRY
import "sketchgraph.nodes.draw" for Draw
import "sketchgraph.nodes.sk_solver" for SkSolver
import "sketchgraph.nodes.solver" for Solver
import "sketchnetwork.variant" for VAR_TYPE_GEOMETRY, VAR_TYPE_CONSTRAINT
import "sketchnetwork.context" for CONTEXT
import "maths.vector" for Vector2
import "graphics" for Painter, Graphics
import "geometry" for Point
import "maths" for Matrix44

class PinInfo
{
	init(geo, name)
	{
		this.geo  = geo
		this.name = name

		this.pos = geo.shape.get()
	}
}

class Sketchgraph is Vertex
{
	init()
	{
		super.init()

		this.shape = SHAPE_PANEL

		this.pin_types_f = [ VAR_TYPE_GEOMETRY ]
		this.pin_types_t = [ 
			[ VAR_TYPE_GEOMETRY, VAR_TYPE_CONSTRAINT ]
		]

		this.pin_dynamic = false

		this.impl = Subgraph()

		this.draw_node = Draw()

		this.pins_info = []

		this.selected = false
	}

	get_title()
	{
		return this.impl.title
	}

	to_string(name) 
	{
		return this.impl.to_string(name)
	}

	on_selected() 
	{
		super.on_selected()

		this.selected = true

		CONTEXT.need_rebuild = true
	}

	on_deselected() 
	{ 
		super.on_deselected()

		this.selected = false

		CONTEXT.need_rebuild = true
	}

	draw(mt, cam_mt)
	{
		super.draw(mt, cam_mt)

		var mat = Matrix44.init()
		var s = this.draw_node.scale * 0.25
		mat.scale(s, s, s)
		mat.translate(this.pos.x, this.pos.y, 0)

		this.draw_node.draw_input(mat)
	}

	draw_pins(mat)
	{
		var pt = Painter.init()
		for (var i in 0 .. this.pins.count)
		{
			var pin = this.pins[i]
			var pos = this.pins_info[i].pos
			pt.add_circle(mat, pos[0], pos[1], 5.0, pin.color, 1.0, 12)
		}
		Graphics.draw_painter(pt)
	}

	load_from_file(editor, filepath)
	{
		this.impl.load_from_file(editor, filepath, editor)

		var v_sketch = Blueprint.calc_output_value(this.impl, "sketch")
		if (!v_sketch) {
			return
		}

		this.reset_geos(v_sketch)
		this.reset_pins(v_sketch)
	}

	reset_geos(v_sketch)
	{
		var solver = SkSolver()
		Blueprint.connect(VariantProxy(v_sketch), "out", solver, "sketch")

		var draw_geos = []

		draw_geos.add(Blueprint.calc_output_value(solver, "geos"))

		Blueprint.connect(VariantProxy(Variant(draw_geos)), "out", this.draw_node, "geo")
	}

	reset_pins(v_sketch)
	{
		this.pins_info.clear()

		for (var i in 0 .. this.impl.exports.count)
		{
			var v_out = Blueprint.calc_output_value(this.impl, i)
			if (v_out.type == VAR_TYPE_GEOMETRY and v_out.value.shape is Point)
			{
				var geo = v_out.value
				var name = this.impl.exports[i].name
				this.pins_info.add(PinInfo(geo, name))

				this.pins.add(Pin(this, 0))
			}
		}

		if (!this.pins_info.isEmpty) {
			this.fix_pins_pos(v_sketch)
		}
	}

	fix_pins_pos(v_sketch)
	{
		var solver = Solver()
		Blueprint.connect(VariantProxy(v_sketch.value.geos), "out", solver, "geo")
		Blueprint.connect(VariantProxy(v_sketch.value.cons), "out", solver, "cons")

		var solved = Blueprint.calc_output_value(solver, "geo")

		for (var pin in this.pins_info)
		{
			for (var geo in solved.value)
			{
				if (geo.value.shape is Point and geo.value.id == pin.geo.id)
				{
					var pos = geo.value.shape.get()
					pin.pos[0] = pos[0]
					pin.pos[1] = pos[1]
				}
			}
		}
	}

	calc_pin_pos(pin)
	{
		for (var i in 0 .. this.pins.count)
		{
			if (this.pins[i] == pin)
			{
				var pos = this.pins_info[i].pos
				var x = pos[0] * this.draw_node.scale * 0.25 + this.pos.x
				var y = pos[1] * this.draw_node.scale * 0.25 + this.pos.y
				return Vector2(x, y)
			}
		}
		return nil
	}

	get_pin_name(pin)
	{
		for (var i in 0 .. this.pins.count) {
			if (this.pins[i] == pin) {
				return this.pins_info[i].name
			}
		}
		return "unknown"
	}

	get_input_geo(pin)
	{
		for (var i in 0 .. this.pins.count) {
			if (this.pins[i] == pin) {
				return this.pins_info[i].geo
			}
		}
		return nil
	}

	query_pin(name)
	{
		for (var i in 0 .. this.pins_info.count) {
			if (this.pins_info[i].name == name) {
				return this.pins[i]
			}
		}
		return nil
	}
}