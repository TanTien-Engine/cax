import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for Variant
import "blueprint.variant_proxy" for VariantProxy
import "blueprint.nodes.subgraph" for Subgraph
import "network.vertex" for Vertex
import "network.pin" for Pin
import "network.vertex_shape" for SHAPE_PANEL
import "sketchgraph.variant" for VAR_TYPE_GEOMETRY
import "sketchgraph.nodes.draw" for Draw
import "sketchgraph.nodes.sk_solver" for SkSolver
import "sketchnetwork.variant" for VAR_TYPE_GEOMETRY, VAR_TYPE_CONSTRAINT
import "sketchnetwork.context" for CONTEXT
import "maths.vector" for Vector2
import "graphics" for Painter, Graphics
import "geometry" for Point
import "maths" for Matrix44

class Sketchgraph is Vertex
{
	init()
	{
		super.init()

		this.shape = SHAPE_PANEL

		this.pin_types_f = [ VAR_TYPE_GEOMETRY ]
		this.pin_types_t = [ 
			[ VAR_TYPE_GEOMETRY, VAR_TYPE_CONSTRAINT ]
		]

		this.pin_dynamic = false

		this.impl = Subgraph()

		this.draw_node = Draw()

		this.pin_geos  = []
		this.pin_names = []

		this.selected = false
	}

	get_title()
	{
		return this.impl.title
	}

	to_string(name) 
	{
		return this.impl.to_string(name)
	}

	on_selected() 
	{
		super.on_selected()

		this.selected = true

		CONTEXT.need_rebuild = true
	}

	on_deselected() 
	{ 
		super.on_deselected()

		this.selected = false

		CONTEXT.need_rebuild = true
	}

	draw(mt, cam_mt)
	{
		super.draw(mt, cam_mt)

		var mat = Matrix44.init()
		var s = this.draw_node.scale * 0.25
		mat.scale(s, s, s)
		mat.translate(this.pos.x, this.pos.y, 0)

		this.draw_node.draw_input(mat)
	}

	draw_pins(mat)
	{
		var pt = Painter.init()
		for (var i in 0 .. this.pins.count)
		{
			var pin = this.pins[i]
			var geo = this.pin_geos[i]
			var pos = geo.shape.get()
			pt.add_circle(mat, pos[0], pos[1], 5.0, pin.color, 1.0, 12)
		}
		Graphics.draw_painter(pt)
	}

	load_from_file(editor, filepath)
	{
		this.impl.load_from_file(editor, filepath, editor)

		var v_sketch = Blueprint.calc_output_value(this.impl, "sketch")
		if (!v_sketch) {
			return
		}

		this.reset_geos(v_sketch)
		this.reset_pins()
	}

	reset_geos(v_sketch)
	{
		var solver = SkSolver()
		Blueprint.connect(VariantProxy(v_sketch), "out", solver, "sketch")

		var draw_geos = []

		draw_geos.add(Blueprint.calc_output_value(solver, "geos"))

		Blueprint.connect(VariantProxy(Variant(draw_geos)), "out", this.draw_node, "geo")
	}

	reset_pins()
	{
		this.pin_geos.clear()
		this.pin_names.clear()
		for (var i in 0 .. this.impl.exports.count)
		{
			var v_out = Blueprint.calc_output_value(this.impl, i)
			if (v_out.type == VAR_TYPE_GEOMETRY and v_out.value.shape is Point)
			{
				this.pin_geos.add(v_out.value)
				this.pin_names.add(this.impl.exports[i].name)
				this.pins.add(Pin(this, 0))
			}
		}
	}

	calc_pin_pos(pin)
	{
		for (var i in 0 .. this.pins.count)
		{
			if (this.pins[i] == pin)
			{
				var geo = this.pin_geos[i]
				var pos = geo.shape.get()
				var x = pos[0] * this.draw_node.scale * 0.25 + this.pos.x
				var y = pos[1] * this.draw_node.scale * 0.25 + this.pos.y
				return Vector2(x, y)
			}
		}
		return nil
	}

	get_pin_name(pin)
	{
		for (var i in 0 .. this.pins.count) {
			if (this.pins[i] == pin) {
				return this.pin_names[i]
			}
		}
		return "unknown"
	}

	get_input_geo(pin)
	{
		for (var i in 0 .. this.pins.count) {
			if (this.pins[i] == pin) {
				return this.pin_geos[i]
			}
		}
		return nil
	}

	query_pin(name)
	{
		for (var i in 0 .. this.pin_names.count) {
			if (this.pin_names[i] == name) {
				return this.pins[i]
			}
		}
		return nil
	}
}