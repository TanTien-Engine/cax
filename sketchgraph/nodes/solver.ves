import "blueprint.node" for Node
import "blueprint.pin" for Pin
import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for Variant, VAR_TYPE_ARRAY, VAR_TYPE_INTEGER
import "blueprint.variant_helper" for VariantHelper
import "sketchgraph.variant" for VAR_TYPE_GEOMETRY, VAR_TYPE_CONSTRAINT, VarGeometry, VarGeoPoint
import "sketchlib" for SketchScene

class Solver is Node
{
	init()
	{
		super.init()

		this.imports = [
			Pin(this, "geo",  [ VAR_TYPE_ARRAY, VAR_TYPE_GEOMETRY ]),
			Pin(this, "cons", [ VAR_TYPE_ARRAY, VAR_TYPE_CONSTRAINT ]),
		]
		this.exports = [
			Pin(this, "geo", [ VAR_TYPE_ARRAY, VAR_TYPE_GEOMETRY ]),
			Pin(this, "dof", VAR_TYPE_INTEGER),
		]

		this.layout()

		this.scene = nil
		this.results = nil
	}

	on_pin_dirty(pin)
	{
		super.on_pin_dirty(pin)

		this.scene = nil
		this.results = nil
	}

	calc_value(idx)
	{
		if (!this.scene) {
			this.scene = this.build_scene()
		}
		if (!this.scene) {
			return nil
		}

		if (idx == 0)
		{
			if (this.results) {
				return this.results
			}

			if (!this.results) {
				this.results = this.build_results()
			}

			return this.results
		}
		else if (idx == 1)
		{
			var dof = this.scene.get_dof()
			return Variant(dof)
		}

		return nil
	}

	geo2params(geo)
	{
		var geo_id = 0
		var point_id = 0
		var shape = nil

		if (geo) 
		{
			if (geo is VarGeometry)
			{
				geo_id = geo.id
				shape = geo.shape
			}
			else if (geo is VarGeoPoint)
			{
				geo_id = geo.geo_id
				point_id = geo.point_id
				shape = geo.shape
			}
		}

		return { "geo_id" : geo_id, "point_id" : point_id, "shape" : shape }
	}

	build_scene()
	{
		var scene = SketchScene.init()

		var v_cons = Blueprint.calc_input_value(this, 1)
		if (v_cons) 
		{
			import "logger.logger" for Logger
			Logger.info("build scene")

			var cons = VariantHelper.flatten_values(v_cons, VAR_TYPE_CONSTRAINT)

			for (var c in cons) 
			{
				var geo1 = this.geo2params(c.geo1)
				var geo2 = this.geo2params(c.geo2)
				scene.add(c.id, c.type, geo1, geo2, c.val, c.driving)
			}
		}

		return scene
	}

	build_results()
	{
		var v_geos = Blueprint.calc_input_value(this, 0)
		if (!v_geos) {
			return nil
		}

		var geos = VariantHelper.flatten_values(v_geos, VAR_TYPE_GEOMETRY)
		var ret_geos = []
		for (var geo in geos) {
			ret_geos.add(Variant(VAR_TYPE_GEOMETRY, geo.clone()))
		}

		if (this.scene) 
		{
			var ids = []
			var shapes = []
			for (var v_geo in ret_geos) {
				ids.add(v_geo.value.id)
				shapes.add(v_geo.value.shape)
			}
			this.scene.solve(ids, shapes)

			import "logger.logger" for Logger
			Logger.info("solve")
		}

		return Variant(ret_geos)
	}
}